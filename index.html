<!DOCTYPE html>
<html>
	<head>
		<title>Last Layer</title>
		<style>
body {
	font-family: "Helvetica Neue", Arial, Sans-Serif;
	display: flex;
}

nav {
	width: 20rem;
	height: 100vh;
	top: 0;
	position: sticky;
	padding: 1rem;
}
twisty-player {
	width: 18rem;
	border: 1px solid grey;
}
main {
	flex-grow: 1;
	padding: 1rem;
	max-width: 50%;
}

a {
	text-decoration: none;
	color: #5d85c1;
}

a:visited {
	color: #5d85c1;
}

ul {
	list-style-type: none;
}

li {
	padding-left: 0;
}
		</style>
	</head>
	<body>
		<nav>
			<twisty-player
				alg="(M2' U M2') U2 (M2' U M2')"
				experimental-setup-anchor="end"
				background="none"
				x-experimental-stickering="EOLL"
				viewer-link="none"
				front-view="bottom-left"
				experimental-title="Where is the title?"
			></twisty-player>
			<ul id="nav" class="nav">

			</ul>
		</nav>
		<main id="main">
			<h1>Last Layer</h1>
		</main>
		<!-- <script src="https://cdn.cubing.net/js/cubing/twisty" type="module"></script> -->
		<script src="https://cdn.cubing.net/js/cubing/twisty" type="module"></script>
		<script type="module">
"use strict";

const sections = [
	{
		label_en: 'PLL',
		class: 'pll',
		stickering: 'PLL',
		subsections: [
			{
				label_en: 'Edges Only',
				cases: [
					{
						label: 'H',
						probability: '1/72',
						swapEdges: [['UL', 'UR'], ['UF', 'UB']],
						algorithms: [
							{
								notation: "(M2' U M2') U2 (M2' U M2')",
							},
							{
								notation: "(M2' U' M2') U2 (M2' U' M2')",
							},
						],
					},
					{
						label: 'Ua',
						probability: '1/18',
						swapEdges: [['UF', 'UR', 'UL']],
						algorithms: [
							{
								notation: "(R U' R U) R U (R U' R' U') R2",
							},
							{
								notation: "(M2 U M) U2 (M' U M2)",
							},
						],
					},
				],
			},
		],
	},
];

var ids = {
	nav: true,
	main: true,
};

const cubeColors = {
	U: 'rgb(255, 255, 255)', // white
	D: 'rgb(255, 254, 85)',  // yellow
	R: 'rgb(235, 51, 35)',   // red
	L: 'rgb(240, 142, 53)',  // orange
	F: 'rgb(117, 250, 76)',  // green
	B: 'rgb(50, 104, 246)',  // blue
};

const faceIndices = {
	B: 0,
	R: 1,
	F: 2,
	L: 3,
};

const cubeWidth = 110;
const cubeHeight = cubeWidth;
const sideFaceWidth = 10;
const cubeletWidth = (cubeWidth - 2 * sideFaceWidth) / 3;

const cubeCorners = [
	// Corner 0, UFR
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// F
		[
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth,
			]
		],
		// R
		[
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth
			]
		],
	],
	// Corner 1, UFL.
	[
		// U
		[
			[
				sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
		],
		// F
		[
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
			[
				0, cubeWidth,
			]
		],
		// L
		[
			[
				0, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
			 	sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				0, cubeWidth,
			],
		]
	],
	// Corner 2, UBL
	[
		// U
		[
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				0, 0,
			],
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
		],
		// L
		[
			[
				0, 0,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				0, sideFaceWidth + cubeletWidth,
			],
		]
	],
	// Corner 3, UBR.
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				0,
			],
			[
				cubeWidth, 0,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
		],
		// R
		[
			[
				cubeWidth, 0,
			],
			[
				cubeWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
		],
	],
];

const cubeEdges = [
	// Edge 0, UF.
	[
		// U.
		[
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// F.
		[
			[
				sideFaceWidth + cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, cubeWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
		],
	],
	// Edge 1, UL.
	[
		// UL.
		[
			// U.
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// L.
			[
				0, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				0, sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
	// Edge 2, UB.
	[
		// UB.
		[
			// U.
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
		],
		[
			// B.
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
		],
	],
	// Edge 4, UR.
	[
		// UR.
		[
			// U.
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// R.
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
];

const edgePositions = {
	UF: 0,
	UL: 1,
	UB: 2,
	UR: 3,
};

const cornerPositions = {
	UFR: 0,
	UFL: 1,
	UBL: 2,
	UBR: 3,
};

window.addEventListener('load', () => {
	const nav = document.getElementById('nav');
	const main = document.getElementById('main');

	for (const section of sections) {
		addSection(section);
	}

	function translatedName(label) {
		return label + '_en';
	}

	function makeId(label) {
		var id = label
			.toLowerCase(label)
			.replaceAll(new RegExp('[^a-zäöüß0-9]+', 'g'), '-')
			.replace(new RegExp('^-+'), '')
			.replace(new RegExp('-+$'), '');
		var suffix = '';
		while (ids.hasOwnProperty(id + '-' + suffix)) {
			++suffix;
		}
		if (suffix) {
			suffix = '-' + suffix;
		}
		ids[id + suffix] = true;

		return id + suffix;
	}

	function addSection(section) {
		const label = section[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		nav.appendChild(li);

		const h = document.createElement('h2');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		main.appendChild(h);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-section');
		li.appendChild(ul);

		for (const subsection of section.subsections) {
			addSubsection(ul, subsection);
		}
	}

	function addSubsection(navList, subsection) {
		const label = subsection[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		main.appendChild(h);

		for (const llcase of subsection.cases) {
			addCase(ul, llcase);
		}
	}

	function addCase(navList, llcase) {
		const label = llcase['label'];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		main.appendChild(h);

		const container = document.createElement('div');
		container.setAttribute('class', 'case');
		const probability = document.createElement('div');
		container.setAttribute('class', 'case-probability');
		container.appendChild(document.createTextNode('p = ' + llcase.probability));

		main.appendChild(container);

		const defaultAlgorithms = llcase.algorithms.filter(a => a.default);
		if (defaultAlgorithms.length) {
			defaultAlgorithms[0].isDefault = true;
		} else {
			llcase.algorithms[0].isDefault = true;
		}

		for (const algorithm of llcase.algorithms) {
			container.appendChild(addAlgorithm(llcase, algorithm, id));
		}
	}

	function addAlgorithm(llcase, algorithm, id) {
		const container = document.createElement('div');
		container.setAttribute('class', 'case-algorithm-container');

		const radioDiv = document.createElement('div');
		radioDiv.setAttribute('class', 'case-default-button');
		const radioButton = document.createElement('input');
		radioButton.setAttribute('type', 'radio');
		radioButton.setAttribute('name', id);
		if (algorithm.isDefault) {
			radioButton.setAttribute('checked', 'checked');
		}
		radioDiv.appendChild(radioButton);

		const label = document.createElement('label');
		label.setAttribute('for', id);
		label.appendChild(document.createTextNode('Favourite'));
		radioDiv.appendChild(label);
		container.appendChild(radioDiv);

		var algorithmDiv = document.createElement('div');
		algorithmDiv.setAttribute('class', 'case-algorithm');
		algorithmDiv.appendChild(document.createTextNode(algorithm.notation));
		container.appendChild(algorithmDiv);

		var canvasDiv = document.createElement('div');
		canvasDiv.setAttribute('class', 'case-algorithm-canvas');
		canvasDiv.appendChild(visualiseLastLayer(llcase, algorithm.rotation));
		container.appendChild(canvasDiv);
		
		return container;
	}

	function visualiseLastLayer(llcase, rotation) {
		var canvas = document.createElement('canvas');

		canvas.setAttribute('width', cubeWidth);
		canvas.setAttribute('height', cubeHeight);

		if (!canvas.getContext) return canvas;

		const ctx = canvas.getContext('2d');

		var cube = {
			edges: ['UF', 'UL', 'UB', 'UR'],
			edgeOrientations: [0, 0, 0, 0],
			corners: ['UFR', 'UFL', 'UBL', 'UBR'],
			cornerOrientations: [0, 0, 0, 0],
		};

		if (rotation) cube = rotateCube(cube, rotation);

		if (llcase.swapEdges) {
			for (var cycle of llcase.swapEdges) {
				cycle = cycle.map(edge => edgePositions[edge]);
				cube = swapEdges(cube, cycle);
			}
		}

		for (var i = 0; i < 4; ++i) {
			drawCubelet(ctx, cube.corners[i], llcase.rotation || 0, cubeCorners[i]);
			drawCubelet(ctx, cube.edges[i], llcase.rotation || 0, cubeEdges[i]);
		}

		const cubeCenter = [
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		];
		drawCubelet(ctx, 'U', 0, [cubeCenter]);

		if (llcase.swapEdges) {
			for (var cycle of llcase.swapEdges) {
				drawArrows(ctx, cycle);
			}
		}

		return canvas;
	}

	function rotateCube(cube, rotation) {
		cube.edges = cycle(cube.edges, rotation);
		cube.corners = cycle(cube.corners, rotation);

		return cube;
	}

	function cycle(array, times) {
		const newArray = [];
		for (var i = 0; i < array.length; ++i) {
			newArray[i] = array[(i + array.length - times) % array.length];
		}

		return newArray;
	}

	function swapEdges(cube, cycle) {
		const first = cube.edges[cycle[0]]
		for (var i = 1; i < cycle.length; ++i) {
			cube.edges[cycle[i - 1]] = cube.edges[cycle[i]];
		}
		cube.edges[cycle[cycle.length - 1]] = first;

		return cube;
	}

	function drawCubelet(ctx, faces, rot, squares) {
		faces = cycle(faces, rot);
		for (var j = 0; j < squares.length; ++j) {
			const points = squares[j];
			ctx.beginPath();
			ctx.moveTo(points[0][0], points[0][1]);
			for (var k = 1; k < points.length; ++k) {
				ctx.lineTo(points[k][0], points[k][1]);
			}
			ctx.lineTo(points[0][0], points[0][1]);
			ctx.fillStyle = cubeColors[faces[j]];
			ctx.fill();
			ctx.stroke();
		}
	}


	function angle(p0, p1) {
		const m = (p1[1] - p0[1]) / (p1[0] - p0[0]);

		return Math.atan(m);
	}

	function drawArrows(ctx, cycle) {
		const coordinates = {
			UFR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UF: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UFL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
			UBL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UB: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UBR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
		};
		
		ctx.strokeStyle = 'rgb(0, 0, 0)';
		ctx.fillStyle = 'rgb(0, 0, 0)';
		for (var i = 1; i < cycle.length; ++i) {
			const start = coordinates[cycle[i]];
			const end = coordinates[cycle[ i == cycle.length - 1 ? 0 : i]];

			const lineAngle = angle(start, end);

			// TODO: Shift the starting point slightly in the direction
			// of the end point.
			ctx.beginPath();
			ctx.moveTo(start[0], start[1]);
			ctx.lineTo(end[0], end[1]);
			ctx.stroke();

			const reverseLineAngle = lineAngle + Math.PI;
			
			ctx.beginPath();
			ctx.moveTo(end[0], end[1]);
			ctx.fill();
		}
	}
});
		</script>
	</body>
</html>
