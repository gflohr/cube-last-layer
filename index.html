<!DOCTYPE html>
<html>
	<head>
		<title class="translatable"
			data-content-en="Last Layer"
			data-content-de="Letzte Ebene">Last Layer</title>
		<style>
body {
	font-family: "Helvetica Neue", Arial, Sans-Serif;
	display: flex;
}

nav {
	width: 20rem;
	height: 100vh;
	top: 0;
	position: sticky;
	padding: 1rem;
}
twisty-player {
	width: 18rem;
	border: 1px solid grey;
}
main {
	flex-grow: 1;
	padding: 1rem;
	max-width: 50%;
}

a {
	text-decoration: none;
	color: #5d85c1;
}

a:visited {
	color: #5d85c1;
}

ul {
	list-style-type: none;
}

li {
	padding-left: 0;
}

.case-probability {
	margin-top: 0.5rem;
	margin-bottom: 1.5rem;
}

.case-algorithm-container {
	display: flex;
	align-items: center;
	margin-bottom: 1rem;
	cursor: pointer;
	font-weight: normal;
	font-size: smaller;
}

.case-algorithm-container:hover {
	background-color: #eeeeee;
}

.case-algorithm-container-selected {
	font-weight: bold;
	font-size: larger;
}

.case-algorithm-container-selected, .case-algorithm-container-selected:hover {
	cursor: default;
	background-color: #dddddd;
}

.case-algorithm-canvas {
	order: 1;
	padding-left: 110px;
}

.case-algorithm-container .case-algorithm-canvas canvas {
	display: none;
}

.case-algorithm-container-selected .case-algorithm-canvas {
	padding-left: 0px;
}

.case-algorithm-container-selected .case-algorithm-canvas canvas {
	padding-left: 0px;
	display: block;
}

.case-algorithm {
	order: 3;
	font-size: 120%;
	margin-left: 1rem;
}

.lingua-selector {
	display: flex;
}

.lingua {
	border: 3px solid transparent;
	height: 15px;
}

.lingua:hover {
	cursor: pointer;
}

.lingua-selected {
	border: 3px solid #ddd;
}

.lingua-selected:hover {
	cursor: default;
}
		</style>
	</head>
	<body>
		<nav>
			<div class="cube" id="cube"></div>
			<ul id="nav" class="nav"></ul>
		</nav>
		<main id="main">
			<div class="lingua-selector">
				<div class="lingua lingua-selected" data-lingua="en">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 30" width="30" height="15">
						<clipPath id="s">
								<path d="M0,0 v30 h60 v-30 z"/>
						</clipPath>
						<clipPath id="t">
								<path d="M30,15 h30 v15 z v15 h-30 z h-30 v-15 z v-15 h30 z"/>
						</clipPath>
						<g clip-path="url(#s)">
								<path d="M0,0 v30 h60 v-30 z" fill="#012169"/>
								<path d="M0,0 L60,30 M60,0 L0,30" stroke="#fff" stroke-width="6"/>
								<path d="M0,0 L60,30 M60,0 L0,30" clip-path="url(#t)" stroke="#C8102E" stroke-width="4"/>
								<path d="M30,0 v30 M0,15 h60" stroke="#fff" stroke-width="10"/>
								<path d="M30,0 v30 M0,15 h60" stroke="#C8102E" stroke-width="6"/>
						</g>
					</svg>
				</div>
				<div class="lingua" data-lingua="de">
					<svg xmlns="http://www.w3.org/2000/svg" width="25" height="15" viewBox="0 0 5 3">
						<rect id="black_stripe" width="5" height="3" y="0" x="0" fill="#000"/>
						<rect id="red_stripe" width="5" height="2" y="1" x="0" fill="#D00"/>
						<rect id="gold_stripe" width="5" height="1" y="2" x="0" fill="#FFCE00"/>
					</svg>
				</div>
			</div>
			<h1 class="translatable"
				data-content-en="Last Layer"
				data-content-de="Letzte Ebene">Last Layer</h1>
			<fieldset>
				<legend
					data-content-en="Method"
					data-content-de="Methode">Method</legend>
				<div>
					<input type="radio" name="method" value="CFOP" 
						class="method-switch" checked>
					<label for="CFOP"
						class="translatable"
					    data-content-en="CFOP"
						data-content-de="CFOP">CFOP</label>
				</div>
				<div>
					<input type="radio" name="method" value="CFOP-4-Look-LL"
						class="method-switch">
					<label for="CFOP-4-Look-LL"
						class="translatable"
					    data-content-en="CFOP (4-Look-Last-Layer)"
						data-content-de="CFOP (letzte Ebene 4-stufig)">Zweistufiges OLL-PLL</label>
				</div>
			</fieldset>
		</main>
		<script src="https://cdn.cubing.net/js/cubing/twisty" type="module"></script>
		<script src="jquery-3.6.3.min.js"></script>
		<script src="roofpig_and_three.min.js"></script>
		<script type="module">
"use strict";

let lingua = 'en';
let method = 'CFOP';

const methods = {
	CFOP: [
		'OLL',
		'PLL',
	],
	'CFOP-4-Look-LL': [
		'EOLL',
		'OCLL',
		'CPOLL',
		'EPLL',
	],
};

const sections = [
	{
		label_en: 'EOLL (Edge Orientation Last Layer)',
		label_de: 'EOLL (Kanten letzte Ebene orientieren)',
		class: 'step',
		step: 'EOLL',
		subsections: [
			{
				label_en: 'Two Edges',
				label_de: 'Zwei Kanten',
				cases: [
					{
						label_en: 'I-Shape',
						label_de: 'I-Form',
						probability: '2/7',
						flipEdges: ['UF', 'UB'],
						algorithms: [
							{
								notation: "F (R U R' U') F'",
							},
							{
								notation: "R U R' U' M' U R U' r'",
							},
						],
					},
					{
						label_en: 'L-Shape',
						label_de: 'L-Form',
						probability: '4/7',
						flipEdges: ['UL', 'UB'],
						algorithms: [
							{
								notation: "f (R U R' U') f'",
							},
							{
								notation: "F (U R U' R') F'",
								rotation: 2,
							},
							{
								notation: "r (U R' U') r' (R U R U' R')",
								rotation: 2,
							},
						],
					},
				],
			},
			{
				label_en: 'Four Edges',
				label_de: 'Vier Kanten',
				cases: [
					{
						label_en: 'Dot-Shape',
						label_de: 'Punkt-Form',
						probability: '1/7',
						flipEdges: ['UF', 'UL', 'UB', 'UR'],
						algorithms: [
							{
								notation: "F (R U R' U') F' f (R U R' U') f'",
							},
						],
					}
				],
			},
		],
	},
	{
		label_en: 'OCLL (Orient Corners Last Layer)',
		label_de: 'OCLL (Ecken letzte Ebene orientieren)',
		class: 'step',
		step: 'OCLL',
		subsections: [
			{
				label_en: 'Four Corners',
				label_de: 'Vier Ecken',
				cases: [
					{
						label_en: 'Pi',
						label_de: 'Pi',
						probability: '2/13',
						flipCorners: {
							UFR: 2,
							UFL: 2,
							UBL: 1,
							UBR: 1,
						},
						algorithms: [
							{
								notation: "R U2' R2' U' R2 U' R2' U2' R",
							},
						],
					},
				],
			},
			{
				label_en: 'Three corners',
				label_de: 'Drei Ecken',
				cases: [
					{
						label_en: 'Antisune',
						label_de: 'Antisune',
						probability: '2/13',
						flipCorners: {
							UFR: 1,
							UFL: 1,
							UBL: 1,
						},
						algorithms: [
							{
								notation: "R U2 R' U' R U' R'",
							},
							{
								notation: "R' U' R U' R' U2 R",
								rotation: 3,
							},
							{
								notation: "L U2' L' U' L U' L'",
								rotation: 2,
							},
							{
								notation: "L' U' L U' L' U2' L",
								rotation: 1,
							},
						],
					},
					{
						label_en: 'Sune',
						label_de: 'Sune',
						probability: '2/13',
						flipCorners: {
							UFR: 2,
							UBL: 2,
							UBR: 2,
						},
						algorithms: [
							{
								notation: "R U R' U R U2 R'",
							},
							{
								notation: "R' U2 R U R' U R",
								rotation: 3,
							},
							{
								notation: "L U L' U L U2' L'",
								rotation: 2,
							},
							{
								notation: "L' U2' L U L' U L",
								rotation: 1,
							},
						],
					}
				],
			}
		],
	},
	{
		label_en: 'EPLL (Edge Permutation Last Layer)',
		label_de: 'EPLL (Kanten letzte Ebene permutieren)',
		class: 'step',
		step: 'EPLL',
		subsections: [
			{
				label_en: 'Three Edges',
				label_de: 'Drei Kanten',
				cases: [
					{
						label: 'Ub',
						probability: '4/11',
						cycleEdges: [['UB', 'UF', 'UL']],
						algorithms: [
							{
								notation: "L2' U S U2 S' U L2",
							},
							{
								notation: "R2 U (R U R' U') R' U' (R' U R')",
								rotation: 3, // 3 times clockwise.
							},
							{
								notation: "(R' U R' U') R' U' (R' U R U) R2'",
								rotation: 1,
							},
							{
								notation: "M2 U' M' U2 M U' M2",
								rotation: 1,
							},
						],
					},
					{
						label: 'Ua',
						probability: '4/11',
						cycleEdges: [['UB', 'UF', 'UR']],
						algorithms: [
							{
								notation: "R2 U' S' U2' S U' R2",
							},
							{
								notation: "(R U' R U) R U (R U' R' U') R2",
								rotation: 1,
							},
							{
								notation: "(R U R' U) (R' U' R2 U') R' U R' U R [U2]",
								rotation: 3,
							},
							{
								notation: "(R2 U' R' U') R U R U (R U' R)",
								rotation: 3,
							},
							{
								notation: "(M2 U M) U2 (M' U M2)",
								rotation: 1,
							},
						],
					},
				],
			},
			{
				label_en: 'Four Edges',
				label_de: 'Vier Kanten',
				cases: [
					{
						label: 'H',
						probability: '1/11',
						cycleEdges: [['UL', 'UR'], ['UF', 'UB']],
						algorithms: [
							{
								notation: "(M2' U M2') U2 (M2' U M2')",
							},
							{
								notation: "(M2' U' M2') U2 (M2' U' M2')",
							},
						],
					},
					{
						label: 'Z',
						probability: '2/11',
						cycleEdges: [['UF', 'UL'], ['UR', 'UB']],
						algorithms: [
							{
								notation: "M' U (M2' U M2') U (M' U2 M2') [U']",
							},
							{
								notation: "M' U' M2 U' M2 U' M' U2 M2 [U]",
								rotation: 1,
							},
							{
								notation: "(M2' U M2' U) (M' U2) (M2' U2 M') [U2]",
								rotation: 1,
							},
							{
								notation: "M2 U' M2 U' M' U2 M2 U2 M' [U2]",
							}
						]
					}
				],
			},
		],
	},
	{
		label_en: 'PLL (Permute Last Layer)',
		label_de: 'PLL (Letzte Ebene permutieren)',
		class: 'step',
		step: 'PLL',
		subsections: [
			{
				label_en: 'Edges Only',
				label_de: 'Nur Kanten',
				cases: [
				{
						label: 'Ub',
						probability: '1/18',
						cycleEdges: [['UB', 'UF', 'UL']],
						algorithms: [
							{
								notation: "L2' U S U2 S' U L2",
							},
							{
								notation: "R2 U (R U R' U') R' U' (R' U R')",
								rotation: 3, // 3 times clockwise.
							},
							{
								notation: "(R' U R' U') R' U' (R' U R U) R2'",
								rotation: 1,
							},
							{
								notation: "M2 U' M' U2 M U' M2",
								rotation: 1,
							},
						],
					},
					{
						label: 'Ua',
						probability: '1/18',
						cycleEdges: [['UB', 'UF', 'UR']],
						algorithms: [
							{
								notation: "R2 U' S' U2' S U' R2",
							},
							{
								notation: "(R U' R U) R U (R U' R' U') R2",
								rotation: 1,
							},
							{
								notation: "(R U R' U) (R' U' R2 U') R' U R' U R [U2]",
								rotation: 3,
							},
							{
								notation: "(R2 U' R' U') R U R U (R U' R)",
								rotation: 3,
							},
							{
								notation: "(M2 U M) U2 (M' U M2)",
								rotation: 1,
							},
						],
					},
					{
						label: 'H',
						probability: '1/72',
						cycleEdges: [['UL', 'UR'], ['UF', 'UB']],
						algorithms: [
							{
								notation: "(M2' U M2') U2 (M2' U M2')",
							},
							{
								notation: "(M2' U' M2') U2 (M2' U' M2')",
							},
						],
					},
					{
						label: 'Z',
						probability: '1/36',
						cycleEdges: [['UF', 'UL'], ['UR', 'UB']],
						algorithms: [
							{
								notation: "M' U (M2' U M2') U (M' U2 M2') [U']",
							},
							{
								notation: "M' U' M2 U' M2 U' M' U2 M2 [U]",
								rotation: 1,
							},
							{
								notation: "(M2' U M2' U) (M' U2) (M2' U2 M') [U2]",
								rotation: 1,
							},
							{
								notation: "M2 U' M2 U' M' U2 M2 U2 M' [U2]",
							}
						]
					}
				],
			},
			{
				label_en: 'Corners Only',
				label_de: 'Nur Ecken',
				cases: [
					{
						label: 'Aa',
						probability: '1/18',
						cycleCorners: [['UBL', 'UBR', 'UFR']],
						algorithms: [
							{
								notation: "x (R' U R') D2 (R U' R') D2 R2 [x']",
							},
							{
								notation: "x' R2 D2 (R' U' R) D2 (R' U R') [x]",
								rotation: 1,
							},
							{
								notation: "x L2 D2 L' U' L D2 L' U L' [x']",
							},
							{
								notation: "x' L' U L' D2 L U' L' D2 L2 [x]",
							},
						],
					},
					{
						label: 'Ab',
						probability: '1/18',
						cycleCorners: [['UBR', 'UBL', 'UFR']],
						algorithms: [
							{
								notation: "x R2' D2 (R U R') D2 (R U' R) [x]",
							},
							{
								notation: "x' (R U' R) D2 (R' U R) D2 R2' [x]",
								rotation: 1,
							},
							{
								notation: "x' L2 D2 L U L' D2 L U' L [x]",
							},
							{
								notation: "x L U' L D2 L' U L D2 L2 [x']",
								rotation: 3,
							},
						],
					},
					{
						label: 'E',
						probability: '1/36',
						cycleCorners: [['UBL', 'UFL'], ['UBR', 'UFR']],
						algorithms: [
							{
								notation: "x' (R U' R' D) (R U R' D') (R U R' D) (R U' R' D') [x]",
							},
							{
								notation: "x' (L' U L D') (L' U' L D) (L' U' L D') (L' U L D) [x]",
							}
						],
					},
				],
			},
			{
				label_en: 'Swap Two Adjacent Corners and Two Edges',
				label_de: 'Zwei nebeneinanderliegende Ecken unc zwei Kanten',
				cases: [
					{
						label: 'Ra',
						probability: '1/18',
						cycleCorners: [['UBR', 'UFR']],
						cycleEdges: [['UL', 'UB']],
						algorithms: [
							{
								notation: "(R U' R' U') (R U R D) (R' U' R D') (R' U2 R') [U'])",
							},
							{
								notation: "(L U2 L' U2) L F' (L' U' L U) L F L2' [U]",
								rotation: 3,
							},
							{
								notation: "(R U R' F') (R U2' R' U2') (R' F R U) (R U2' R') [U']",
							},
						],
					}
				],
			},
		],
	},
];

var ids = {
	nav: true,
	main: true,
};

const cubeColors = {
	U: 'rgb(255, 254, 85)',  // yellow
	D: 'rgb(255, 255, 255)', // white
	F: 'rgb(235, 51, 35)',   // red
	B: 'rgb(240, 142, 53)',  // orange
	R: 'rgb(117, 250, 76)',  // green
	L: 'rgb(50, 104, 246)',  // blue
	G: 'rgb(128, 128, 128)', // grey for irrelevant stickers
};

const faceIndices = {
	B: 0,
	R: 1,
	F: 2,
	L: 3,
};

const cornerIndices = {
	UFR: 0,
	UFL: 1,
	UBL: 2,
	UBR: 3,
}

const swapRotations = [
	{
		UB: 'UB',
		UR: 'UR',
		UF: 'UF',
		UL: 'UL',
		UBR: 'UBR',
		UFR: 'UFR',
		UFL: 'UFL',
		UBL: 'UBL',
	},
	{
		UB: 'UR',
		UR: 'UF',
		UF: 'UL',
		UL: 'UB',
		UBR: 'UFR',
		UFR: 'UFL',
		UFL: 'UBL',
		UBL: 'UBR',
	},
	{
		UB: 'UF',
		UR: 'UL',
		UF: 'UB',
		UL: 'UR',
		UBR: 'UFL',
		UFR: 'UBL',
		UFL: 'UBR',
		UBL: 'UFR',
	},
	{
		UB: 'UL',
		UR: 'UB',
		UF: 'UR',
		UL: 'UF',
		UBR: 'UBL',
		UFR: 'UBR',
		UFL: 'UFR',
		UBL: 'UFL',
	},
];

const swapFlips = {
	UBR: {
		UFR: 1,
		UBL: 1,
	},
	UFR: {
		UFL: 1,
		UBR: 1,
	},
	UFL: {
		UBL: 1,
		UFR: 1,
	},
	UBL: {
		UBR: 1,
		UFL: 1,
	},
};

const cubeWidth = 110;
const cubeHeight = cubeWidth;
const sideFaceWidth = 15;
const cubeletWidth = (cubeWidth - 2 * sideFaceWidth) / 3;

// The corners of the cube. All faces are drawn in clock-wise direction,
// always starting with U.
const cubeCorners = [
	// Corner 0, UFR
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// R
		[
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth
			]
		],
		// F
		[
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth,
			]
		],
	],
	// Corner 1, UFL.
	[
		// U
		[
			[
				sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
		],
		// F
		[
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
			[
				0, cubeWidth,
			]
		],
		// L
		[
			[
				0, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
			 	sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				0, cubeWidth,
			],
		]
	],
	// Corner 2, UBL
	[
		// U
		[
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
		],
		// L
		[
			[
				0, 0,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				0, sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				0, 0,
			],
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
		],
	],
	// Corner 3, UBR.
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				0,
			],
			[
				cubeWidth, 0,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
		],
		// R
		[
			[
				cubeWidth, 0,
			],
			[
				cubeWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
		],
	],
];

const cubeEdges = [
	// Edge 0, UF.
	[
		// U.
		[
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// F.
		[
			[
				sideFaceWidth + cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, cubeWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
		],
	],
	// Edge 1, UL.
	[
		// UL.
		[
			// U.
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// L.
			[
				0, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				0, sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
	// Edge 2, UB.
	[
		// UB.
		[
			// U.
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
		],
		[
			// B.
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
		],
	],
	// Edge 4, UR.
	[
		// UR.
		[
			// U.
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// R.
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
];

const edgePositions = {
	UF: 0,
	UL: 1,
	UB: 2,
	UR: 3,
};

const cornerPositions = {
	UFR: 0,
	UFL: 1,
	UBL: 2,
	UBR: 3,
};

window.addEventListener('load', () => {
	let cube = createRoofpig('#cube', 'alg=', 'class="roofpig"');

	const nav = document.getElementById('nav');
	const main = document.getElementById('main');

	for (const switcher of document.getElementsByClassName('lingua')) {
		switcher.onclick = () => onLanguageSwitch(switcher);
	}

	for (const switcher of document.getElementsByClassName('method-switch')) {
		switcher.onchange = () => switchMethod(switcher.value);
	}

	for (const section of sections) {
		addSection(section);
	}

	const newLingua = localStorage.getItem('last-layer-lingua');
	if (['en', 'de'].includes(newLingua)) {
		lingua = newLingua;
	}

	const newMethod = localStorage.getItem('last-layer-method');
	if (methods.hasOwnProperty(newMethod)) {
		method = newMethod;
	}

	switchLanguage(lingua);
	switchMethod(method);

	function createRoofpig(parent, config, attributes) {
		let obj = CubeAnimation.create_in_dom(parent, config, attributes);
		if (!obj.dom) {
			// This shuts up the false positive error message for file URLs.
			const div = $('.roofpig')
				.html('')
				.text('')
				.css('background', '');
			
			// And this makes remove() work.
			obj.dom = { div: div };
		}

		return obj;
	}

	function onLanguageSwitch(switcher) {
		switchLanguage(switcher.dataset.lingua);
	}

	function switchLanguage(newLingua) {
		for (const other of document.getElementsByClassName('lingua')) {
			const l = other.dataset.lingua;
			if (l === newLingua) {
				other.setAttribute('class', 'lingua lingua-selected');
			} else {
				other.setAttribute('class', 'lingua');
			}
		}

		lingua = newLingua;
		localStorage.setItem('last-layer-lingua', lingua);

		translate();
	}

	function switchMethod(newMethod) {
		method = newMethod;
		localStorage.setItem('last-layer-method', method);
		for (const switcher of document.getElementsByClassName('method-switch')) {
			if (switcher.value === method)
				switcher.setAttribute('checked', 'checked');
			else
				switcher.removeAttribute('checked');
		}
		for (const elem of document.getElementsByClassName('step')) {
			if (methods[method].includes(elem.dataset.step)) {
				elem.style.display = 'block';
			} else {
				elem.style.display = 'none';
			}
		}
	}

	function translate() {
		const dataAttribute = 'content'
			+ lingua.charAt(0).toUpperCase() + lingua.slice(1).toLowerCase();
		for (const elem of document.getElementsByClassName('translatable')) {
			elem.innerHTML = elem.dataset[dataAttribute];
		}
	}

	function translatedName(label) {
		return label + '_' + lingua;
	}

	function makeId(label) {
		var id = label
			.toLowerCase(label)
			.replaceAll(new RegExp('[^a-zäöüß0-9]+', 'g'), '-')
			.replace(new RegExp('^-+'), '')
			.replace(new RegExp('-+$'), '')
			.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
		var suffix = '';
		while (ids.hasOwnProperty(id + '-' + suffix)) {
			++suffix;
		}
		if (suffix) {
			suffix = '-' + suffix;
		}
		ids[id + suffix] = true;

		return id + suffix;
	}

	function makeTranslatable(elem, object) {
		elem.dataset.contentEn = object.label_en || object.label;
		elem.dataset.contentDe = object.label_de || object.label;
		let classAttr = elem.getAttribute('class');
		if (classAttr) {
			elem.setAttribute('class', classAttr + ' translatable');
		} else {
			elem.setAttribute('class', 'translatable');
		}
	}

	function addSection(section) {
		const label = section[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, section);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.setAttribute('class', 'step');
		li.setAttribute('data-step', section.step);
		li.appendChild(link);
		nav.appendChild(li);

		const container = document.createElement('div');
		container.setAttribute('class', 'step');
		container.setAttribute('data-step', section.step);
		main.appendChild(container);

		const h = document.createElement('h2');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		makeTranslatable(h, section);
		container.appendChild(h);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-section');
		li.appendChild(ul);

		for (const subsection of section.subsections) {
			addSubsection(container, ul, subsection, section.step);
		}
	}

	function addSubsection(stepContainer, navList, subsection, step) {
		const label = subsection[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, subsection);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		makeTranslatable(h, subsection);
		stepContainer.appendChild(h);

		for (const llcase of subsection.cases) {
			addCase(stepContainer, ul, llcase, step);
		}
	}

	function addCase(stepContainer, navList, llcase, step) {
		const label = llcase[translatedName('label')] || llcase['label'];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, llcase);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		makeTranslatable(h, llcase);
		h.appendChild(document.createTextNode(label));
		stepContainer.appendChild(h);

		const container = document.createElement('div');
		container.setAttribute('class', 'case');

		const probability = document.createElement('div');
		probability.setAttribute('class', 'case-probability');
		probability.appendChild(document.createTextNode('p = ' + llcase.probability));
		container.appendChild(probability);

		stepContainer.appendChild(container);

		for (const algorithm of llcase.algorithms) {
			algorithm.canonical = algorithm.notation.replace(/[^ UDFBRLMESxyz2']/ig, '');
		}

		const defaultAlgorithm = localStorage.getItem(
			'last-layer-default-' + id)
			|| llcase.algorithms[0].canonical;

		const defaultAlgorithms = llcase.algorithms.filter(a => a.canonical === defaultAlgorithm);
		defaultAlgorithms[0].isDefault = true;

		for (const algorithm of llcase.algorithms) {
			container.appendChild(addAlgorithm(llcase, algorithm, id, step));
		}
	}

	function addAlgorithm(llcase, algorithm, id, step) {
		const container = document.createElement('div');
		container.dataset.canonical = algorithm.canonical;

		if (algorithm.isDefault) {
			container.setAttribute(
				'class',
				'case-algorithm-container case-algorithm-container-selected'
			);
		} else {
			container.setAttribute('class', 'case-algorithm-container');
		}
		container.onclick = () => {
			const caseDiv = container.parentElement;
			for (const elem of caseDiv.getElementsByClassName('case-algorithm-container')) {
				elem.setAttribute('class', 'case-algorithm-container');
			}
			container.setAttribute('class', 'case-algorithm-container case-algorithm-container-selected');
			if (cube) {
				cube.remove();
			}

			let config = "alg=" + algorithm.canonical;
			if ('EOLL' === step) {
				config += '|solved=D DFL DF DFR DR DBR DB DBL DL DFL F R B L FR BR BL FL'
					+ '|colored=U Uf Ur Ul Ub';
			} else if ('OLL' === step || 'OCLL' === step) {
				config += '|solved=D DFL DF DFR DR DBR DB DBL DL DFL F R B L FR BR BL FL'
					+ '|colored=u';
			}
			if (algorithm.rotation) {
				let setupmoves = '|setupmoves=';
				switch(algorithm.rotation) {
					case 1:
						setupmoves += 'y';
						break;
					case 2:
						setupmoves += 'y2';
						break;
					case 3:
						setupmoves += 'y\'';
						break;
				}
				config += setupmoves;
			}
			config += '|flags=showalg|algdisplay=2p';
			cube = createRoofpig('#cube', config, "class='roofpig'");

			localStorage.setItem('last-layer-default-' + id, container.dataset.canonical);
		};

		var algorithmDiv = document.createElement('div');
		algorithmDiv.setAttribute('class', 'case-algorithm');
		algorithmDiv.appendChild(document.createTextNode(algorithm.notation));
		container.appendChild(algorithmDiv);

		var canvasDiv = document.createElement('div');
		canvasDiv.setAttribute('class', 'case-algorithm-canvas');
		canvasDiv.appendChild(visualiseLastLayer(llcase, algorithm.rotation, step));
		container.appendChild(canvasDiv);

		return container;
	}

	function cycleArray(array, times) {
		const newArray = [];
		for (var i = 0; i < array.length; ++i) {
			newArray[i] = array[(i + array.length - times) % array.length];
		}

		return newArray;
	}

	function cycleSwaps(swaps, rotation) {
		const cycledSwaps = [];
		for (let i = 0; i < swaps.length; ++i) {
			cycledSwaps[i] = swapRotations[rotation][swaps[i]];
		}

		return cycledSwaps;
	}

	function visualiseLastLayer(llcase, rotation, step) {
		if (!rotation) rotation = 0;

		var canvas = document.createElement('canvas');
		canvas.setAttribute('width', cubeWidth);
		canvas.setAttribute('height', cubeHeight);

		if (!canvas.getContext) return canvas;

		const ctx = canvas.getContext('2d');

		let cube = {
			edges: ['UF', 'UL', 'UB', 'UR'],
			edgeOrientations: [0, 0, 0, 0],
			corners: ['UFR', 'UFL', 'UBL', 'UBR'],
			cornerOrientations: [0, 0, 0, 0],
		};

		if (llcase.cycleEdges) {
			for (let cycle of llcase.cycleEdges) {
				cycle = cycle.map(edge => edgePositions[edge]);
				cube = cycleEdges(cube, cycle);
			}
		}

		if (llcase.flipEdges) {
			for (let i = 0; i < cube.edges.length; ++i) {
				if (llcase.flipEdges.includes(cube.edges[i])) {
					cube.edgeOrientations[i] = 1;
				}
			}
		}

		if (llcase.cycleCorners) {
			for (let cycle of llcase.cycleCorners) {
				cycle = cycle.map(corner => cornerPositions[corner]);
				cube = cycleCorners(cube, cycle);
			}
		}

		if (rotation) {
			cube = rotateCube(cube, rotation);
		}

		// The corners are flipped after the cube is rotated because the
		// orientations given refer to the final state of the cube.
		if (llcase.flipCorners) {
			const order = ['UFR', 'UFL', 'UBL', 'UBR'];
			for (let corner in llcase.flipCorners) {
				const orientation = llcase.flipCorners[corner];

				// Change the orientation of the corner where the specified
				// corner started.
				const index = cube.corners.indexOf(corner);
				cube.cornerOrientations[index] += orientation;
			}
		}

		for (var i = 0; i < 4; ++i) {
			drawCubelet(ctx, cube.corners[i], cube.cornerOrientations[i],
				cubeCorners[i], step);
			drawCubelet(ctx, cube.edges[i], cube.edgeOrientations[i],
				cubeEdges[i], step);
		}

		const cubeCenter = [
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		];
		drawCubelet(ctx, 'U', 0, [cubeCenter]);

		let swaps = [];
		if (llcase.cycleEdges) {
			for (let cycle of llcase.cycleEdges)
				swaps.push(cycle);
		}
		if (llcase.cycleCorners) {
			for (let cycle of llcase.cycleCorners)
				swaps.push(cycle);
		}

		for (let cycle of swaps) {
			if (rotation) {
				cycle = cycleSwaps(cycle, rotation);
			}
			drawArrows(ctx, cycle);
		}

		return canvas;
	}

	function rotateCube(cube, rotation) {
		cube.edges = cycleArray(cube.edges, rotation);
		cube.edgeOrientations = cycleArray(cube.edgeOrientations, rotation);
		cube.corners = cycleArray(cube.corners, rotation);
		cube.cornerOrientations = cycleArray(cube.cornerOrientations, rotation);

		return cube;
	}

	function cycleEdges(cube, cycle) {
		const first = cube.edges[cycle[0]]
		for (var i = 1; i < cycle.length; ++i) {
			cube.edges[cycle[i - 1]] = cube.edges[cycle[i]];
		}
		cube.edges[cycle[cycle.length - 1]] = first;

		return cube;
	}

	function cycleCorners(cube, cycle) {
		const first = cube.corners[cycle[0]]
		for (var i = 1; i < cycle.length; ++i) {
			cube.corners[cycle[i - 1]] = cube.corners[cycle[i]];
		}
		cube.corners[cycle[cycle.length - 1]] = first;

		return cube;
	}

	function drawCubelet(ctx, faces, rot, squares, step) {
		rot = rot % 3;
		faces = cycleArray(faces, rot).join('');
		for (var j = 0; j < squares.length; ++j) {
			const points = squares[j];
			ctx.beginPath();
			ctx.moveTo(points[0][0], points[0][1]);
			for (var k = 1; k < points.length; ++k) {
				ctx.lineTo(points[k][0], points[k][1]);
			}
			ctx.lineTo(points[0][0], points[0][1]);
			ctx.fillStyle = stickerColor(faces[j], faces, step);
			ctx.fill();
			ctx.stroke();
		}
	}

	function stickerColor(face, piece, step) {
		switch(step) {
			case 'OLL':
			case 'OCLL':
				if (face != 'U') {
					face = 'G';
				}
				break;
			case 'EOLL':
				if (face !== 'U' || 3 === piece.length) {
					face = 'G';
				}
				break;
		};

		// UFR and UBL are in anti-clockwise direction.
		if ('UFR' === piece) {
			if ('F' === face) {
				face = 'R';
			} else if ('R' === face) {
				face = 'F';
			}
		} else if ('UBL' === piece) {
			if ('B' === face) {
				face = 'L';
			} else if ('L' === face) {
				face = 'B';
			}
		}

		return cubeColors[face];
	}

	function drawArrow (ctx, p1, p2) {
		const angle = Math.atan2((p2[1] - p1[1]) , (p2[0] - p1[0]));
		const hyp = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));
		const size = 7;

		ctx.save();
		ctx.translate(p1[0], p1[1]);
		ctx.rotate(angle);

		ctx.beginPath();	
		ctx.moveTo(0, 0);
		ctx.lineTo(hyp - size, 0);
		ctx.stroke();

		ctx.beginPath();
		ctx.lineTo(hyp - size, size);
		ctx.lineTo(hyp, 0);
		ctx.lineTo(hyp - size, -size);
		ctx.fill();

		ctx.restore();
	}

	function drawArrows(ctx, cycle) {
		const coordinates = {
			UFR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UF: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UFL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
			UBL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UB: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UBR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
		};
		
		ctx.strokeStyle = 'rgb(0, 0, 0)';
		ctx.fillStyle = 'rgb(0, 0, 0)';

		for (var i = 0; i < cycle.length; ++i) {
			const start = coordinates[cycle[i]];
			const end = coordinates[cycle[ i == cycle.length - 1 ? 0 : i + 1]];
			drawArrow(ctx, start, end);
		}
	}
});
		</script>
	</body>
</html>
