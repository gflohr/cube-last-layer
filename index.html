<!DOCTYPE html>
<html>
	<head>
		<title class="translatable"
			data-content-en="Last Layer"
			data-content-de="Letzte Ebene">Last Layer</title>
		<style>
body {
	font-family: "Helvetica Neue", Arial, Sans-Serif;
	font-size: 1.2rem;
	display: flex;
}

nav {
	width: 20rem;
	height: 100vh;
	top: 0;
	position: sticky;
	padding: 1rem;
}

main {
	flex-grow: 1;
	padding: 1rem;
	max-width: 50%;
}

a {
	text-decoration: none;
	color: #5d85c1;
}

a:visited {
	color: #5d85c1;
}

ul {
	list-style-type: none;
}

li {
	padding-left: 0;
}

.remark {
	margin-bottom: 1rem;
}

.important-algorithm {
	cursor: pointer;
}

.case-probability {
	margin-top: 0.5rem;
	margin-bottom: 1.5rem;
}

.case-detection {
	margin-top: -1.5rem;
	margin-bottom: 1.5rem;
}

.case-algorithm-container {
	display: flex;
	align-items: center;
	margin-bottom: 1rem;
	cursor: pointer;
	font-weight: normal;
	font-size: smaller;
}

.case-algorithm-container:hover {
	background-color: #eeeeee;
}

.case-algorithm-container .case-algorithm-remark {
	display: none;
}

.case-algorithm-container-selected {
	font-weight: bold;
	font-size: larger;
}

.case-algorithm-container-selected, .case-algorithm-container-selected:hover {
	cursor: default;
	background-color: #dddddd;
}

.case-algorithm-container-selected .case-algorithm-remark {
	font-weight: normal;
	font-size: 70%;
	display: block;
}

.case-algorithm-canvas {
	order: 1;
	padding-left: 110px;
}

.case-algorithm-container .case-algorithm-canvas canvas {
	display: none;
}

.case-algorithm-container-selected .case-algorithm-canvas {
	padding-left: 0px;
}

.case-algorithm-container-selected .case-algorithm-canvas canvas {
	padding-left: 0px;
	display: block;
}

.case-algorithm {
	order: 3;
	font-size: 120%;
	margin-left: 1rem;
}

.lingua-selector {
	display: flex;
}

.lingua {
	border: 0.2rem solid transparent;
	height: 15px;
}

.lingua:hover {
	cursor: pointer;
}

.lingua-selected {
	border: 0.2rem solid #bbb;
	font-size: 1rem;
}

.lingua-selected:hover {
	cursor: default;
}
		</style>
	</head>
	<body>
		<nav>
			<div class="cube" id="cube"></div>
			<ul id="nav" class="nav"></ul>
		</nav>
		<main id="main">
			<div class="lingua-selector">
				<div class="lingua lingua-selected" data-lingua="en">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 30" width="30" height="15">
						<clipPath id="s">
								<path d="M0,0 v30 h60 v-30 z"/>
						</clipPath>
						<clipPath id="t">
								<path d="M30,15 h30 v15 z v15 h-30 z h-30 v-15 z v-15 h30 z"/>
						</clipPath>
						<g clip-path="url(#s)">
								<path d="M0,0 v30 h60 v-30 z" fill="#012169"/>
								<path d="M0,0 L60,30 M60,0 L0,30" stroke="#fff" stroke-width="6"/>
								<path d="M0,0 L60,30 M60,0 L0,30" clip-path="url(#t)" stroke="#C8102E" stroke-width="4"/>
								<path d="M30,0 v30 M0,15 h60" stroke="#fff" stroke-width="10"/>
								<path d="M30,0 v30 M0,15 h60" stroke="#C8102E" stroke-width="6"/>
						</g>
					</svg>
				</div>
				<div class="lingua" data-lingua="de">
					<svg xmlns="http://www.w3.org/2000/svg" width="25" height="15" viewBox="0 0 5 3">
						<rect id="black_stripe" width="5" height="3" y="0" x="0" fill="#000"/>
						<rect id="red_stripe" width="5" height="2" y="1" x="0" fill="#D00"/>
						<rect id="gold_stripe" width="5" height="1" y="2" x="0" fill="#FFCE00"/>
					</svg>
				</div>
			</div>
			<h1 class="translatable"
				data-content-en="Last Layer"
				data-content-de="Letzte Ebene">Last Layer</h1>
			<fieldset>
				<legend
					data-content-en="Method"
					data-content-de="Methode">Method</legend>
				<div>
					<input type="radio" name="method" value="CFOP" 
						class="method-switch" checked>
					<label for="CFOP"
						class="translatable"
					    data-content-en="CFOP"
						data-content-de="CFOP">CFOP</label>
				</div>
				<div>
					<input type="radio" name="method" value="CFOP-4-Look-LL"
						class="method-switch">
					<label for="CFOP-4-Look-LL"
						class="translatable"
					    data-content-en="CFOP (4-Look-Last-Layer)"
						data-content-de="CFOP (letzte Ebene 4-stufig)">Zweistufiges OLL-PLL</label>
				</div>
			</fieldset>
			<div>
				<h2 class="translatable"
					data-content-en="Notes"
					data-content-de="Hinweise"></h2>
				<h3 class="translatable"
					data-content-en="General"
					data-content-de="Allgemeines"></h3>
				<div class="translatable remark"
					data-content-en="You can click on any algorithm in order to select it as your favourite and replay it on the cube to the left."
					data-content-de="Wenn du auf einen beliebigen Algorithmus klickst, speicherst du ihn als bevorzugten Algorithmus und kannst am Würfel links alle Drehungen abspielen."></div>
				<div class="translatable remark"
					data-content-en="In PLL (and CPOLL), the displayed side face stickers are just examples. The last layer can be rotated in any way!"
					data-content-de="Bei PLL (und CPOLL) sind die dargestellten Seitensticker nur Beispiele. Die letzte Ebene kann beliebig gedreht sein."></div>
				<div class="translatable remark"
					data-content-en="Do not waste time turning the lower two layers before the algorithms below to match the displayed cube. Especially for PLL (and CPOLL) just wait (or anticipate), and Adjust the Upper Face (AUF) with a final U turn.  If the algorithm ends with a U turn, it is put in [angle brackets] because it can be replaced by an arbitrary U turn or be skipped altogether, depending on the rotation of the first two layers."
					data-content-de="Verschwende keine Zeit damit, die unteren beiden Ebenen so zu drehen, dass sie dem dargestellten Würfel entsprechen. Besonders für PLL (und CPOLL) warte (oder wisse, was kommt), und löse den Würfel mit einer finalen U-Drehung (AUF = Adjust Upper Face). Falls der Algorithmus mit einer U-Drehung endet, steht diese in [eckigen Klammern], weil sie je nach Rotation der ersten beiden Ebene durch eine beliebige andere U-Drehung ersetzt oder auch ganz weggelassen werden kann."></div>
				<h3 class="translatable"
					data-content-en="Important Algorithms"
					data-content-de="Wichtige Algorithmen"></h3>
				<div class="translatable"
					data-content-en="You can click on the algorithm in order to replay it on the cube to the left."
					data-content-de="Wenn du auf den Algorithmus klickst, kannst du am Würfel links alle Drehungen abspielen."></div>
				<h4 class="translatable"
					data-content-en="Sexy Move"
					data-content-de="Sexy Move"></h4>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Right:"
						data-content-de="Rechts:"></span>
					<span>R U R' U'</span>
				</div>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Left:"
						data-content-de="Links:"></span>
					<span>L' U' L U</span>
				</div>
				<h4 class="translatable"
					data-content-en="Reverse Sexy Move"
					data-content-de="Umgekehrter Sexy Move"></h4>
				<div class="translatable remark"
					data-content-en="This is not the sexy move turned backwards but the move that undoes the sexy move."
					data-content-de="Das ist nicht der Sexy Move in umgekehrter Reihenfolge, sondern der Zug, der den Sexy Move rückgängig macht.">
				</div>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Right:"
						data-content-de="Rechts:"></span>
					<span>U R U' R'</span>
				</div>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Left:"
						data-content-de="Links:"></span>
					<span>U' L' U L</span>
				</div>
				<h4 class="translatable"
					data-content-en="Sledgehammer"
					data-content-de="Vorschlaghammer"></h4>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Right:"
						data-content-de="Rechts:"></span>
					<span>R' F R F'</span>
				</div>
				<div class="important-algorithm">
					<span class="translatable"
						data-content-en="Left:"
						data-content-de="Links:"></span>
					<span>L F' L' F</span>
				</div>
				<h4 class="translatable"
					data-content-en="Hedgeslammer (reverse sledgehammer)"
					data-content-de="Hedgeslammer (umgekehrter Sledgehammer/Hedgeslammer)"></h4>
				<div class="translatable remark"
					data-content-en="This is not the sledgehammer turned backwards but the move that undoes the sledgehammer."
					data-content-de="Das ist nicht der Sledgehammer in umgekehrter Reihenfolge, sondern der Zug, der den Sledgehammer rückgängig macht.">
				</div>
				<div>
					<span class="translatable"
						data-content-en="Right:"
						data-content-de="Rechts:"></span>
					<span>U R U' R'</span>
				</div>
				<div>
					<span class="translatable"
						data-content-en="Left:"
						data-content-de="Links:"></span>
					<span>U' L' U L</span>
				</div>
			</div>
		</main>
		<script src="jquery-3.6.3.min.js"></script>
		<script src="roofpig_and_three.min.js"></script>
		<script type="module">
"use strict";

let lingua = 'en';
let method = 'CFOP';

const methods = {
	CFOP: [
		'OLL',
		'PLL',
	],
	'CFOP-4-Look-LL': [
		'EOLL',
		'OCLL',
		'CPOLL',
		'EPLL',
	],
};

const sections = [
	{
		label_en: 'EOLL (Edge Orientation Last Layer)',
		label_de: 'EOLL (Kanten letzte Ebene orientieren)',
		class: 'step',
		step: 'EOLL',
		subsections: [
			{
				label_en: 'Two Edges',
				label_de: 'Zwei Kanten',
				cases: [
					{
						label_en: 'I-Shape',
						label_de: 'I-Form',
						probability: '2/7',
						flipEdges: ['UF', 'UB'],
						algorithms: [
						{
								notation: "F (R U R' U') F'",
								label_en: "Rotate front face, sexy move, and rotate back.",
								label_de: "Vorderseite drehen, Sexy Move, and Vorderseite zurückdrehen.",
							},
							{
								notation: "F' (L' U' L U) F",
								label_en: "Rotate front face, sexy move, and rotate back.",
								label_de: "Vorderseite drehen, Sexy Move, and Vorderseite zurückdrehen.",
							},
							{
								notation: "R U R' U' M' U R U' r'",
							},
							{
								notation: "L' U' L U M' U' L' U l",
							},
						],
					},
					{
						label_en: 'L-Shape',
						label_de: 'L-Form',
						probability: '4/7',
						flipEdges: ['UL', 'UB'],
						algorithms: [
						{
								notation: "f (R U R' U') f'",
								label_en: 'Like the I-shape but with wide F-turns.',
								label_de: 'Wie die I-Form, aber mit weiten F-Drehungen.',
							},
							{
								notation: "f' (L' U' L U) f",
								label_en: 'Like the I-shape but with wide F-turns.',
								label_de: 'Wie die I-Form, aber mit weiten F-Drehungen.',
								rotation: 1,
							},
							{
								notation: "F (U R U' R') F'",
								label_en: "Rotate front face, reverse sexy move, and rotate back.",
								label_de: "Vorderseite drehen, umgekehrter Sexy Move, und Vorderseite zurückdrehen.",
								rotation: 2,
							},
							{
								notation: "F' (U' L' U L) F",
								label_en: "Rotate front face, reverse sexy move, and rotate back.",
								label_de: "Vorderseite drehen, umgekehrter Sexy Move, und Vorderseite zurückdrehen.",
								rotation: 3,
							},
							{
								notation: "r (U R' U') r' (R U R U' R')",
								rotation: 2,
							},
							{
								notation: "l' (U' L U) l (L' U' L' U L)",
								rotation: 3,
							},
						],
					},
				],
			},
			{
				label_en: 'Four Edges',
				label_de: 'Vier Kanten',
				cases: [
					{
						label_en: 'Dot-Shape',
						label_de: 'Punkt-Form',
						probability: '1/7',
						flipEdges: ['UF', 'UL', 'UB', 'UR'],
						algorithms: [
							{
								notation: "F (R U R' U') F' f (R U R' U') f'",
								label_en: "First do the algorithm of the I-shape, and then solve the resulting L-shape.",
								label_de: "Erst den Algorithmus für die I-Form anwenden, und dann die daraus resultierende L-Form lösen.",
							},
							{
								notation: "F' (L' U' L U) F f' (L' U' L U) f",
								label_en: "First do the algorithm of the I-shape, and then solve the resulting L-shape.",
								label_de: "Erst den Algorithmus für die I-Form anwenden, und dann die daraus resultierende L-Form lösen.",
							},
						],
					}
				],
			},
		],
	},
	{
		label_en: 'OCLL (Orient Corners Last Layer)',
		label_de: 'OCLL (Ecken letzte Ebene orientieren)',
		class: 'step',
		step: 'OCLL',
		subsections: [
			{
				label_en: 'Four Corners',
				label_de: 'Vier Ecken',
				cases: [
					{
						label: 'Pi',
						detection_en: 'two headlights, two blinkers.',
						detection_de: 'Zwei Scheinwerfer, zwei Blinker.',
						probability: '2/13',
						flipCorners: {
							UFR: 2,
							UFL: 2,
							UBL: 1,
							UBR: 1,
						},
						algorithms: [
							{
								notation: "R U2' R2' U' R2 U' R2' U2' R",
								label_en: 'Start: Right middle finger on top-right edge, right thumb on bottom-right edge. Do not let go these pieces during the entire algorithm.',
								label_de: 'Ausgangsposition: Den rechten Mittelfinger auf der oberen rechten Kante lassen, und den rechten Daumen auf der unteren linken Kante. Diese Teile während des ganzen Algorithmus\' nicht mehr loslassen.',
							},
							{
								notation: "L' U2 L2 U L2' U L2 U2 L'",
								label_en: 'Start: Left middle finger on top-left edge, left thumb on bottom-left edge. Do not let go these pieces during the entire algorithm.',
								label_de: 'Ausgangsposition: Den linken Mittelfinger auf der oberen linken Kante lassen, und den linken Daumen auf der unteren linken Kante. Diese Teile während des ganzen Algorithmus\' nicht mehr loslassen.',
								rotation: 2,
							},
						],
					},
					{
						label: 'H',
						probability: '1/13',
						detection_en: 'two pairs of headlights.',
						detection_de: 'Zwei Paar Scheinwerfer.',
						flipCorners: {
							UFR: 2,
							UFL: 1,
							UBL: 2,
							UBR: 1,
						},
						algorithms: [
							{
								notation: "F (R U R' U') (R U R' U') (R U R' U') F'",
								label_en: "Rotate front face, three times sexy move, and rotate back; almost the same as the I-shape of EOLL.",
								label_de: "Vorderseite rotieren, dreimal Sexy Move, und zurückdrehen; fast dasselbe wie die I-Form von EOLL."
							},
							{
								notation: "(R U R' U) (R U' R' U) R U2 R'",
								rotation: 1,
							},
						],
					}
				],
			},
			{
				label_en: 'Three corners',
				label_de: 'Drei Ecken',
				cases: [
					{
						label_en: 'Antisune',
						label_de: 'Antisune',
						probability: '2/13',
						detection_en: 'All three corners are twisted once in clock-wise direction.',
						detection_de: 'Alle drei Ecken sind einmal im Uhrzeigersinn verdreht.',
						flipCorners: {
							UFR: 1,
							UFL: 1,
							UBL: 1,
						},
						algorithms: [
							{
								notation: "R U2 R' U' R U' R'",
							},
							{
								notation: "R' U' R U' R' U2 R",
								rotation: 3,
							},
							{
								notation: "L U2' L' U' L U' L'",
								rotation: 2,
							},
							{
								notation: "L' U' L U' L' U2' L",
								rotation: 1,
							},
						],
					},
					{
						label_en: 'Sune',
						label_de: 'Sune',
						probability: '2/13',
						detection_en: 'All three corners are twisted twice in clock-wise direction.',
						detection_de: 'Alle drei Ecken sind zweimal im Uhrzeigersinn verdreht.',
						flipCorners: {
							UFR: 2,
							UBL: 2,
							UBR: 2,
						},
						algorithms: [
							{
								notation: "R U R' U R U2 R'",
							},
							{
								notation: "R' U2 R U R' U R",
								rotation: 3,
							},
							{
								notation: "L U L' U L U2' L'",
								rotation: 2,
							},
							{
								notation: "L' U2' L U L' U L",
								rotation: 1,
							},
						],
					}
				],
			},
			{
				label_en: 'Two Corners',
				label_de: 'Zwei Ecken',
				cases: [
					{
						label: 'L',
						probability: '2/13',
						detection_en: 'Two diagonally opposite corners are twisted.',
						detection_de: 'Zwei diagonal gegenüberliegende Ecken sind verdreht.',
						flipCorners: {
							UFL: 1,
							UBR: 2,
						},
						algorithms: [
							{
								notation: "(F R' F' r) (U R U' r')",
								label_en: "Hedgeslammer and reverse sexy move, but the last R turns of both moves as a wide turn. Both U face stickers must be visible!",
								label_de: "Hedgeslammer und umgekehrter Sexy Move, aber die jeweils letzte Drehung als weite Drehung ausführen. Beide U-Seiten-Sticker müssen sichtbar sein!",
							},
							{
								notation: "(F' L F l') (U' L' U l)",
								rotation: 1,
								label_en: "Hedgeslammer and reverse sexy move, but the last l turns of both moves as a wide turn. One U face sticker on the right side pointing forward!",
								label_de: "Hedgeslammer und umgekehrter Sexy Move, aber die jeweils letzte L-Drehung als weite Drehung ausführen. Ein U-Seiten-Sticker muss rechts nach vorne zeigen!",
							},
							{
								notation: "x (R' U R D') (R' U' R D) x'",
								label_en: "Both U face stickers must be visible!",
								label_de: "Beide U-Seiten-Sticker müssen sichtbar sein!",
							},
							{
								notation: "x (L U' L' D) (L U L' D') x'",
								rotation: 1,
								label_en: "One U face sticker on the right side pointing forward!",
								label_de: "Ein U-Seiten-Sticker muss rechts nach vorne zeigen!",
							},
						],
					},
					{
						label: 'T',
						probability: '2/13',
						detection_en: 'Two adjacent blinkers.',
						detection_de: 'Zwei nebeneinanderliegende Blinker',
						flipCorners: {
							UFL: 1,
							UBL: 2,
						},
						algorithms: [
							{
								notation: "(r U R' U') (r' F R F')",
								label_en: "Sledgehammer and sexy move, but the last R turns of both moves as a wide turn.",
								label_de: "Sledgehammer und Sexy Move, aber die jeweils letzte R-Drehung als weite Drehung ausführen.",
							},
							{
								notation: "(l' U' L U) (l F' L' F)",
								rotation: 2,
								label_en: "Sledgehammer and sexy move, but the last L turns of both moves as a wide turn.",
								label_de: "Sledgehammer und Sexy Move, aber die jeweils letzte L-Drehung als weite Drehung ausführen.",
							},
							{
								notation: "x (R' U' L U) (R U' L' U) x'",
								rotation: 2,
							},
							{
								notation: "x (L U R' U') (L' U R U') x'",
							},
						],
					},
					{
						label: 'U',
						probability: '2/13',
						detection_en: 'Two adjacent headlights.',
						detection_de: 'Zwei nebeneinanderliegende Scheinwerfer',
						flipCorners: {
							UFR: 2,
							UFL: 1,
						},
						algorithms: [
							{
								notation: "R2 (D R' U2 R) (D' R' U2 R')",
							},
							{
								notation: "R2' D' (R U2 R') D (R U2 R)",
								rotation: 2,
							},
						],
					},
				],
			},
		],
	},
	{
		label_en: 'CPOLL (Corner Permutation of Last Layer)',
		label_de: 'CPOLL (Ecken letzte Ebene permutieren)',
		class: 'step',
		step: 'CPOLL',
		subsections: [
			{
				label_en: 'Zwei Ecken',
				label_de: 'Zwei Ecken',
				cases: [
					{
						label: 'Diagonal',
						probability: '?',
						detection_en: 'There are no headlights.',
						detection_de: 'Es gibt keine Scheinwerfer.',
						cycleCorners: [['UFR', 'UBL']],
						algorithms: [
						{
								notation: "(F R) (U' R' U' R U) (R' F') + (R U R' U') (R' F R F')",
								label_en: 'Second part is sexy move plus sledgehammer. Try to rotate the cube or just the U face so that the front and right edge are solved because that let\'s you skip the last step!',
								label_de: 'Zweiter Teil ist der Sexy Move plus Sledgehammer. Versuche den Würfel oder die U-Seite so zu drehen, dass die vordere und rechte Kante gelöst sind, weil dann der letzte Schritt übersprungen werden kann!',
							},
							{
								notation: "(F' L') (U L U L' U') (L F) + (L' U' L U) (L F' L' F)",
								rotation: 1,
								label_en: 'Second part is sexy move plus sledgehammer. Try to rotate the cube or just the U face so that the front and left edge are solved because that let\'s you skip the last step!',
								label_de: 'Zweiter Teil ist der Sexy Move plus Sledgehammer. Versuche den Würfel oder die U-Seite so zu drehen, dass die vordere und linke Kante gelöst sind, weil dann der letzte Schritt übersprungen werden kann!',
							},
						],
					},
					{
						label: 'Nebeneinander',
						probability: '?',
						detection_en: 'There are exactly two headlights.',
						detection_de: 'Es gibt exakt zwei Scheinwerfer.',
						cycleCorners: [['UFR', 'UBR']],
						algorithms: [
						{
								notation: "(R U R' U') (R' F) + R2 + (U' R' U' R U) (R' F')",
								label_en: 'The two parts of the diagonal case swapped but the sequence "R F\' F R" in the middle is optimized into just "R2".',
								label_de: 'Die zwei Teile des Diagonal-Falls vertauscht, aber die Folge "R F\' F R" in der Mitte ist zu "R2" optimiert.',
							},
							{
								notation: "(R U R' U') (R' F R F') + (F R U' R' U' R U) (R' F')",
								label_en: 'The two parts of the diagonal case swapped. Do NOT use! Use the optimized algorithm above instead!',
								label_de: 'Die zwei Teile des Diagonal-Falls vertauscht. Nicht verwenden! Der optimierte Algorithmus direkt hier vor ist besser!',
							},
							{
								notation: "(L' U' L U) (L F') + L2 + (U L U L' U') (L F)",
								rotation: 2,
								label_en: 'The two parts of the diagonal case swapped but the sequence "L F F\' L\'" in the middle is optimized into just "L2".',
								label_de: 'Die zwei Teile des Diagonal-Falls vertauscht, aber die Folge "L F F\' L\'" in der Mitte ist zu "L2" optimiert.',
							},
							{
								notation: "(L' U' L U) (L F' L' F) + (F' L' U L U L' U') (L F)",
								rotation: 2,
								label_en: 'The two parts of the diagonal case swapped. Do NOT use! Use the optimized algorithm above instead!',
								label_de: 'Die zwei Teile des Diagonal-Falls vertauscht. Nicht verwenden! Der optimierte Algorithmus direkt hier vor ist besser!',
							},
						],
					},
				],
			},
		],
	},
	{
		label_en: 'EPLL (Edge Permutation Last Layer)',
		label_de: 'EPLL (Kanten letzte Ebene permutieren)',
		class: 'step',
		step: 'EPLL',
		subsections: [
			{
				label_en: 'Three Edges',
				label_de: 'Drei Kanten',
				cases: [
					{
						label: 'Ub',
						probability: '4/11',
						cycleEdges: [['UB', 'UF', 'UL']],
						algorithms: [
							{
								notation: "L2' U S U2 S' U L2",
								label_en: 'Start position: left thumb at left front-bottom, middle finger left back-bottom. Do not let go these pieces.  First S turn with the right index finger of the right hand, the second one with the left.',
								label_de: 'Ausgangsstellung: Linker Daumen vorne, links unten, Mittelfinger hinten, links unten und diese Teile nicht loslassen. Die erste S-Drehung mit dem rechten Zeigefinger, die zweite mit dem linken machen.',
							},
							{
								notation: "R2 U (R U R' U') R' U' (R' U R')",
								rotation: 3,
							},
							{
								notation: "(R' U R' U') R' U' (R' U R U) R2'",
								rotation: 1,
							},
							{
								notation: "M2 U' M' U2 M U' M2",
								rotation: 1,
							},
						],
					},
					{
						label: 'Ua',
						probability: '4/11',
						cycleEdges: [['UB', 'UF', 'UR']],
						algorithms: [
							{
								notation: "R2 U' S' U2' S U' R2",
								label_en: 'Start position: right thumb at right front-bottom, middle finger right back-bottom. Do not let go these pieces.  First S turn with the left index finger, the second one with the right.',
								label_de: 'Ausgangsstellung: Linker Daumen vorne, links unten, Mittelfinger hinten, links unten und diese Teile nicht loslassen. Die erste S-Drehung mit dem rechten Zeigefinger, die zweite mit dem linken machen.',
							},
							{
								notation: "(R U' R U) R U (R U' R' U') R2",
								rotation: 1,
							},
							{
								notation: "(R U R' U) (R' U' R2 U') R' U R' U R [U2]",
								rotation: 3,
							},
							{
								notation: "(R2 U' R' U') R U R U (R U' R)",
								rotation: 3,
							},
							{
								notation: "(M2 U M) U2 (M' U M2)",
								rotation: 1,
							},
						],
					},
				],
			},
			{
				label_en: 'Four Edges',
				label_de: 'Vier Kanten',
				cases: [
					{
						label: 'H',
						probability: '1/11',
						cycleEdges: [['UL', 'UR'], ['UF', 'UB']],
						algorithms: [
							{
								notation: "(M2' U M2') U2 (M2' U M2')",
							},
							{
								notation: "(M2' U' M2') U2 (M2' U' M2')",
							},
						],
					},
					{
						label: 'Z',
						probability: '2/11',
						cycleEdges: [['UF', 'UL'], ['UR', 'UB']],
						algorithms: [
							{
								notation: "M' U (M2' U M2') U (M' U2 M2') [U']",
							},
							{
								notation: "M' U' M2 U' M2 U' M' U2 M2 [U]",
								rotation: 1,
							},
							{
								notation: "(M2' U M2' U) (M' U2) (M2' U2 M') [U2]",
								rotation: 1,
							},
							{
								notation: "M2 U' M2 U' M' U2 M2 U2 M' [U2]",
							}
						]
					}
				],
			},
		],
	},
	{
		label_en: 'PLL (Permute Last Layer)',
		label_de: 'PLL (Letzte Ebene permutieren)',
		class: 'step',
		step: 'PLL',
		subsections: [
			{
				label_en: 'Edges Only',
				label_de: 'Nur Kanten',
				cases: [
				{
						label: 'Ub',
						probability: '1/18',
						cycleEdges: [['UB', 'UF', 'UL']],
						algorithms: [
							{
								notation: "L2' U S U2 S' U L2",
							},
							{
								notation: "R2 U (R U R' U') R' U' (R' U R')",
								rotation: 3, // 3 times clockwise.
							},
							{
								notation: "(R' U R' U') R' U' (R' U R U) R2'",
								rotation: 1,
							},
							{
								notation: "M2 U' M' U2 M U' M2",
								rotation: 1,
							},
						],
					},
					{
						label: 'Ua',
						probability: '1/18',
						cycleEdges: [['UB', 'UF', 'UR']],
						algorithms: [
							{
								notation: "R2 U' S' U2' S U' R2",
							},
							{
								notation: "(R U' R U) R U (R U' R' U') R2",
								rotation: 1,
							},
							{
								notation: "(R U R' U) (R' U' R2 U') R' U R' U R [U2]",
								rotation: 3,
							},
							{
								notation: "(R2 U' R' U') R U R U (R U' R)",
								rotation: 3,
							},
							{
								notation: "(M2 U M) U2 (M' U M2)",
								rotation: 1,
							},
						],
					},
					{
						label: 'H',
						probability: '1/72',
						cycleEdges: [['UL', 'UR'], ['UF', 'UB']],
						algorithms: [
							{
								notation: "(M2' U M2') U2 (M2' U M2')",
							},
							{
								notation: "(M2' U' M2') U2 (M2' U' M2')",
							},
						],
					},
					{
						label: 'Z',
						probability: '1/36',
						cycleEdges: [['UF', 'UL'], ['UR', 'UB']],
						algorithms: [
							{
								notation: "M' U (M2' U M2') U (M' U2 M2') [U']",
							},
							{
								notation: "M' U' M2 U' M2 U' M' U2 M2 [U]",
								rotation: 1,
							},
							{
								notation: "(M2' U M2' U) (M' U2) (M2' U2 M') [U2]",
								rotation: 1,
							},
							{
								notation: "M2 U' M2 U' M' U2 M2 U2 M' [U2]",
							}
						]
					}
				],
			},
			{
				label_en: 'Corners Only',
				label_de: 'Nur Ecken',
				cases: [
					{
						label: 'Aa',
						probability: '1/18',
						detection_en: 'A full block and headlights in clock-wise direction.',
						detection_de: 'Ein Block und ein Paar Scheinwerfer im Uhrzeigersinn hintereinander.',
						cycleCorners: [['UBL', 'UBR', 'UFR']],
						algorithms: [
							{
								notation: "x (R' U R') D2 (R U' R') D2 R2 [x']",
							},
							{
								notation: "x' (L' U L') D2' (L U' L') D2' L2' [x]",
								rotation: 2,
							},
							{
								notation: "x' R2 D2' (R' U' R) D2' (R' U R') [x]",
								rotation: 1,
							},
							{
								notation: "x L2' D2 (L' U' L) D2 (L' U L') [x']",
								rotation: 3,
							},
						],
					},
					{
						label: 'Ab',
						probability: '1/18',
						detection_en: 'A full block und headlights in counterclock-wise direction.',
						detection_de: 'Ein Block und ein Paar Scheinwerfer gegen den Uhrzeigersinn hintereinander.',
						cycleCorners: [['UBR', 'UBL', 'UFR']],
						algorithms: [
							{
								notation: "x R2' D2 (R U R') D2 (R U' R) [x']",
							},
							{
								notation: "x' L2 D2' (L U L') D2' (L U' L) [x]",
								rotation: 2,
							},
							{
								notation: "x' (R U' R) D2' (R' U R) D2' R2' [x]",
								rotation: 1,
							},
							{
								notation: "x (L U' L) D2 (L' U L) D2 L2 [x']",
								rotation: 3,
							},
						],
					},
					{
						label: 'E',
						probability: '1/36',
						detection_en: 'no block, all edges solved (no H perm or Z perm).',
						detection_de: 'Kein Block, alle Kanten gelöst (nicht H-Perm oder Z-Perm).',
						cycleCorners: [['UBL', 'UFL'], ['UBR', 'UFR']],
						algorithms: [
							{
								notation: "x' (R U' R' D) (R U R' D') (R U R' D) (R U' R' D') [x]",
							},
							{
								notation: "x' (L' U L D') (L' U' L D) (L' U' L D') (L' U L D) [x]",
							}
						],
					},
				],
			},
			{
				label_en: 'Swap Two Adjacent Corners and Two Edges',
				label_de: 'Zwei nebeneinanderliegende Ecken und zwei Kanten',
				cases: [
					{
						label: 'Ra',
						probability: '1/18',
						detection_en: 'Adjacent half block and headlights in clockwise direction.',
						detection_de: 'Halber Block und Scheinwerfer im Uhrzeigersinn aneinandergrenzend.',
						cycleCorners: [['UBR', 'UFR']],
						cycleEdges: [['UL', 'UB']],
						algorithms: [
							{
								notation: "(R U' R' U') (R U R D) (R' U' R D') (R' U2 R') [U'])",
							},
							{
								notation: "(L U2' L' U2) L F' (L' U' L U) (L F L2') [U]",
								rotation: 3,
							},
							{
								notation: "(R U R' F') (R U2' R' U2') (R' F R U) (R U2' R') [U']",
							},
							{
								// Found by Herbert Kociemba's optimal solver.
								notation: "(R U' R' U' R) (L' D L U' L') (D' L U' R') [U']",
							},
							{
								// Found by Herbert Kociemba's optimal solver.
								notation: "(R U L' D) L U L' D' R' L U R U R' [U]",
								rotation: 1,
							},
							{
								// Found by Herbert Kociemba's optimal solver.
								notation: "L2 F' L' U' L U L U' F L F' U F L",
							},
							{
								// Found by Herbert Kociemba's optimal solver.
								notation: "L' F' U' F L' F' U L' U' L' U L F L2",
							},
						],
					}
				],
			},
		],
	},
];

const cubeColors = {
	U: 'rgb(255, 254, 85)',  // yellow
	D: 'rgb(255, 255, 255)', // white
	F: 'rgb(235, 51, 35)',   // red
	B: 'rgb(240, 142, 53)',  // orange
	R: 'rgb(117, 250, 76)',  // green
	L: 'rgb(50, 104, 246)',  // blue
	G: 'rgb(128, 128, 128)', // grey for irrelevant stickers
};

const faceIndices = {
	B: 0,
	R: 1,
	F: 2,
	L: 3,
};

const cornerIndices = {
	UFR: 0,
	UFL: 1,
	UBL: 2,
	UBR: 3,
}

const swapRotations = [
	{
		UB: 'UB',
		UR: 'UR',
		UF: 'UF',
		UL: 'UL',
		UBR: 'UBR',
		UFR: 'UFR',
		UFL: 'UFL',
		UBL: 'UBL',
	},
	{
		UB: 'UR',
		UR: 'UF',
		UF: 'UL',
		UL: 'UB',
		UBR: 'UFR',
		UFR: 'UFL',
		UFL: 'UBL',
		UBL: 'UBR',
	},
	{
		UB: 'UF',
		UR: 'UL',
		UF: 'UB',
		UL: 'UR',
		UBR: 'UFL',
		UFR: 'UBL',
		UFL: 'UBR',
		UBL: 'UFR',
	},
	{
		UB: 'UL',
		UR: 'UB',
		UF: 'UR',
		UL: 'UF',
		UBR: 'UBL',
		UFR: 'UBR',
		UFL: 'UFR',
		UBL: 'UFL',
	},
];

const swapFlips = {
	UBR: {
		UFR: 1,
		UBL: 1,
	},
	UFR: {
		UFL: 1,
		UBR: 1,
	},
	UFL: {
		UBL: 1,
		UFR: 1,
	},
	UBL: {
		UBR: 1,
		UFL: 1,
	},
};

const cubeWidth = 110;
const cubeHeight = cubeWidth;
const sideFaceWidth = 15;
const cubeletWidth = (cubeWidth - 2 * sideFaceWidth) / 3;

// The corners of the cube. All faces are drawn in clock-wise direction,
// always starting with U.
const cubeCorners = [
	// Corner 0, UFR
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// R
		[
			[
				cubeWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth
			]
		],
		// F
		[
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				cubeWidth, cubeWidth,
			],
			[
				cubeWidth - cubeletWidth - sideFaceWidth,
				cubeWidth,
			]
		],
	],
	// Corner 1, UFL.
	[
		// U
		[
			[
				sideFaceWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[	
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
		],
		// F
		[
			[
				sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
			[
				0, cubeWidth,
			]
		],
		// L
		[
			[
				0, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth, cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
			 	sideFaceWidth, cubeWidth - sideFaceWidth,
			],
			[
				0, cubeWidth,
			],
		]
	],
	// Corner 2, UBL
	[
		// U
		[
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
		],
		// L
		[
			[
				0, 0,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				0, sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				0, 0,
			],
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth, sideFaceWidth,
			],
		],
	],
	// Corner 3, UBR.
	[
		// U
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
		],
		// B
		[
			[
				cubeWidth - sideFaceWidth - cubeletWidth,
				0,
			],
			[
				cubeWidth, 0,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
			[
				cubeWidth - sideFaceWidth - cubeletWidth, sideFaceWidth,
			],
		],
		// R
		[
			[
				cubeWidth, 0,
			],
			[
				cubeWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth - sideFaceWidth, sideFaceWidth,
			],
		],
	],
];

const cubeEdges = [
	// Edge 0, UF.
	[
		// U.
		[
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth - cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth,
				cubeWidth - sideFaceWidth,
			],
		],
		// F.
		[
			[
				sideFaceWidth + cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 3 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, cubeWidth,
			],
			[
				sideFaceWidth + cubeletWidth, cubeWidth,
			],
		],
	],
	// Edge 1, UL.
	[
		// UL.
		[
			// U.
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// L.
			[
				0, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				0, sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
	// Edge 2, UB.
	[
		// UB.
		[
			// U.
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
		],
		[
			// B.
			[
				sideFaceWidth + cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, 0,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth,
			],
		],
	],
	// Edge 4, UR.
	[
		// UR.
		[
			// U.
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
		[
			// R.
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth,
				sideFaceWidth + cubeletWidth,
			],
			[
				cubeWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + 3 * cubeletWidth,
				sideFaceWidth + 2 * cubeletWidth,
			],
		],
	],
];

const edgePositions = {
	UF: 0,
	UL: 1,
	UB: 2,
	UR: 3,
};

const cornerPositions = {
	UFR: 0,
	UFL: 1,
	UBL: 2,
	UBR: 3,
};

window.addEventListener('load', () => {
	let cube = createRoofpig('#cube', 'alg=', 'class="roofpig"');

	const nav = document.getElementById('nav');
	const main = document.getElementById('main');

	for (const switcher of document.getElementsByClassName('lingua')) {
		switcher.onclick = () => onLanguageSwitch(switcher);
	}

	for (const switcher of document.getElementsByClassName('method-switch')) {
		switcher.onchange = () => switchMethod(switcher.value);
	}

	for (const div of document.getElementsByClassName('important-algorithm')) {
		div.onclick = () => displayImportantAlgorithm(div);
	}

	for (const section of sections) {
		addSection(section);
	}

	const newLingua = localStorage.getItem('last-layer-lingua');
	if (['en', 'de'].includes(newLingua)) {
		lingua = newLingua;
	}

	const newMethod = localStorage.getItem('last-layer-method');
	if (methods.hasOwnProperty(newMethod)) {
		method = newMethod;
	}

	switchLanguage(lingua);
	switchMethod(method);

	function displayImportantAlgorithm(div) {
		const notation = div.getElementsByTagName('span')[1].innerText;
		const config = 'alg=' + notation
			+ '|setupmoves=' + notation
			+ '|flags=showalg';
		cube.remove();
		cube = createRoofpig('#cube', config, 'class="roofpig"');
	}

	function createRoofpig(parent, config, attributes) {
		let obj = CubeAnimation.create_in_dom(parent, config, attributes);
		if (!obj.dom) {
			// This shuts up the false positive error message for file URLs.
			const div = $('.roofpig')
				.html('')
				.text('')
				.css('background', '');
			
			// And this makes remove() work.
			obj.dom = { div: div };
		}

		return obj;
	}

	function onLanguageSwitch(switcher) {
		switchLanguage(switcher.dataset.lingua);
	}

	function switchLanguage(newLingua) {
		for (const other of document.getElementsByClassName('lingua')) {
			const l = other.dataset.lingua;
			if (l === newLingua) {
				other.setAttribute('class', 'lingua lingua-selected');
			} else {
				other.setAttribute('class', 'lingua');
			}
		}

		lingua = newLingua;
		localStorage.setItem('last-layer-lingua', lingua);

		translate();
	}

	function switchMethod(newMethod) {
		method = newMethod;
		localStorage.setItem('last-layer-method', method);
		for (const switcher of document.getElementsByClassName('method-switch')) {
			if (switcher.value === method)
				switcher.setAttribute('checked', 'checked');
			else
				switcher.removeAttribute('checked');
		}
		for (const elem of document.getElementsByClassName('step')) {
			if (methods[method].includes(elem.dataset.step)) {
				elem.style.display = 'block';
			} else {
				elem.style.display = 'none';
			}
		}
	}

	function translate() {
		const dataAttribute = 'content'
			+ lingua.charAt(0).toUpperCase() + lingua.slice(1).toLowerCase();
		for (const elem of document.getElementsByClassName('translatable')) {
			elem.innerHTML = elem.dataset[dataAttribute];
		}
	}

	function translatedName(label) {
		return label + '_' + lingua;
	}

	function makeId(label) {
		var id = label
			.toLowerCase(label)
			.replaceAll(new RegExp('[^a-zäöüß0-9]+', 'g'), '-')
			.replace(new RegExp('^-+'), '')
			.replace(new RegExp('-+$'), '')
			.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
		let suffix = '';
		while (document.getElementById(id + suffix)) {
			--suffix;
		}

		return id + suffix;
	}

	function makeTranslatable(elem, object) {
		elem.dataset.contentEn = object.label_en || object.label;
		elem.dataset.contentDe = object.label_de || object.label;
		let classAttr = elem.getAttribute('class');
		if (classAttr) {
			elem.setAttribute('class', classAttr + ' translatable');
		} else {
			elem.setAttribute('class', 'translatable');
		}
	}

	function addSection(section) {
		const label = section[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, section);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.setAttribute('class', 'step');
		li.setAttribute('data-step', section.step);
		li.appendChild(link);
		nav.appendChild(li);

		const container = document.createElement('div');
		container.setAttribute('class', 'step');
		container.setAttribute('data-step', section.step);
		main.appendChild(container);

		const h = document.createElement('h2');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		makeTranslatable(h, section);
		container.appendChild(h);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-section');
		li.appendChild(ul);

		for (const subsection of section.subsections) {
			addSubsection(container, ul, subsection, section.step);
		}
	}

	function addSubsection(stepContainer, navList, subsection, step) {
		const label = subsection[translatedName('label')];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, subsection);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		h.appendChild(document.createTextNode(label));
		makeTranslatable(h, subsection);
		stepContainer.appendChild(h);

		for (const llcase of subsection.cases) {
			addCase(stepContainer, ul, llcase, step);
		}
	}

	function addCase(stepContainer, navList, llcase, step) {
		const label = llcase[translatedName('label')] || llcase['label'];
		const id = makeId(label);

		const link = document.createElement('a');
		link.setAttribute('href', '#' + id);
		link.appendChild(document.createTextNode(label));
		makeTranslatable(link, llcase);
		const li = document.createElement('li');
		li.setAttribute('id', label);
		li.appendChild(link);
		navList.appendChild(li);

		const ul = document.createElement('ul');
		ul.setAttribute('class', 'nav-cases');
		li.appendChild(ul);

		const h = document.createElement('h3');
		h.setAttribute('id', id);
		makeTranslatable(h, llcase);
		h.appendChild(document.createTextNode(label));
		stepContainer.appendChild(h);

		const container = document.createElement('div');
		container.setAttribute('class', 'case');

		const probability = document.createElement('div');
		probability.setAttribute('class', 'case-probability');
		probability.appendChild(document.createTextNode('p = ' + llcase.probability));
		container.appendChild(probability);

		const detection = llcase[translatedName('detection')];
		if (detection !== undefined) {
			const detectionDiv = document.createElement('div');
			container.appendChild(detectionDiv);

			detectionDiv.appendChild(document.createTextNode(''));
			detectionDiv.setAttribute('class', 'case-detection');
			makeTranslatable(detectionDiv, {
				label_en: 'Detection: ' + llcase.detection_en,
				label_de: 'Erkennung: ' + llcase.detection_de,
			});
		}

		stepContainer.appendChild(container);

		for (const algorithm of llcase.algorithms) {
			algorithm.canonical = algorithm.notation.replace(/[^ UDFBRLMESxyz2']/ig, '');
		}

		const defaultAlgorithm = localStorage.getItem(
			'last-layer-default-' + id)
			|| llcase.algorithms[0].canonical;

		const defaultAlgorithms = llcase.algorithms.filter(a => a.canonical === defaultAlgorithm);
		if (defaultAlgorithms.length) {
			defaultAlgorithms[0].isDefault = true;
		} else {
			llcase.algorithms[0].isDefault = true;
		}

		for (const algorithm of llcase.algorithms) {
			container.appendChild(addAlgorithm(llcase, algorithm, id, step));
		}
	}

	function addAlgorithm(llcase, algorithm, id, step) {
		const container = document.createElement('div');
		container.dataset.canonical = algorithm.canonical;

		if (algorithm.isDefault) {
			container.setAttribute(
				'class',
				'case-algorithm-container case-algorithm-container-selected'
			);
		} else {
			container.setAttribute('class', 'case-algorithm-container');
		}
		container.onclick = () => {
			const caseDiv = container.parentElement;
			for (const elem of caseDiv.getElementsByClassName('case-algorithm-container')) {
				elem.setAttribute('class', 'case-algorithm-container');
			}
			container.setAttribute('class', 'case-algorithm-container case-algorithm-container-selected');
			if (cube) {
				cube.remove();
			}

			let config = "alg=" + algorithm.canonical;
			config += '|solved=D DFL DF DFR DR DBR DB DBL DL DFL F R B L FR BR BL FL';
			if ('EOLL' === step) {
				config += '|colored=U Uf Ur Ul Ub';
			} else if ('CPOLL' === step) {
				config += '|colored=U UFR UFL UBR UBL'
			} else if ('OLL' === step || 'OCLL' === step) {
				config += '|colored=u';
			}
			if (algorithm.rotation) {
				let setupmoves = '|setupmoves=';
				switch(algorithm.rotation) {
					case 1:
						setupmoves += 'y';
						break;
					case 2:
						setupmoves += 'y2';
						break;
					case 3:
						setupmoves += 'y\'';
						break;
				}
				config += setupmoves;
			}
			config += '|flags=showalg|algdisplay=2p';
			cube = createRoofpig('#cube', config, "class='roofpig'");

			localStorage.setItem('last-layer-default-' + id, container.dataset.canonical);
		};

		var algorithmDiv = document.createElement('div');
		algorithmDiv.setAttribute('class', 'case-algorithm');
		algorithmDiv.appendChild(document.createTextNode(algorithm.notation));
		container.appendChild(algorithmDiv);

		const remark = algorithm[translatedName('label')];
		if (remark !== undefined) {
			var remarkDiv = document.createElement('div');
			algorithmDiv.appendChild(remarkDiv);
			remarkDiv.setAttribute('class', 'case-algorithm-remark');
			makeTranslatable(remarkDiv, algorithm);
		}

		var canvasDiv = document.createElement('div');
		canvasDiv.setAttribute('class', 'case-algorithm-canvas');
		canvasDiv.appendChild(visualiseLastLayer(llcase, algorithm.rotation, step));
		container.appendChild(canvasDiv);

		return container;
	}

	function cycleArray(array, times) {
		const newArray = [];
		for (var i = 0; i < array.length; ++i) {
			newArray[i] = array[(i + array.length - times) % array.length];
		}

		return newArray;
	}

	function cycleSwaps(swaps, rotation) {
		const cycledSwaps = [];
		for (let i = 0; i < swaps.length; ++i) {
			cycledSwaps[i] = swapRotations[rotation][swaps[i]];
		}

		return cycledSwaps;
	}

	function visualiseLastLayer(llcase, rotation, step) {
		if (!rotation) rotation = 0;

		var canvas = document.createElement('canvas');
		canvas.setAttribute('width', cubeWidth);
		canvas.setAttribute('height', cubeHeight);

		if (!canvas.getContext) return canvas;

		const ctx = canvas.getContext('2d');

		let cube = {
			edges: ['UF', 'UL', 'UB', 'UR'],
			edgeOrientations: [0, 0, 0, 0],
			corners: ['UFR', 'UFL', 'UBL', 'UBR'],
			cornerOrientations: [0, 0, 0, 0],
		};

		if (llcase.cycleEdges) {
			for (let cycle of llcase.cycleEdges) {
				cycle = cycle.map(edge => edgePositions[edge]);
				cube = cycleEdges(cube, cycle);
			}
		}

		if (llcase.flipEdges) {
			for (let i = 0; i < cube.edges.length; ++i) {
				if (llcase.flipEdges.includes(cube.edges[i])) {
					cube.edgeOrientations[i] = 1;
				}
			}
		}

		if (llcase.cycleCorners) {
			for (let cycle of llcase.cycleCorners) {
				cycle = cycle.map(corner => cornerPositions[corner]);
				cube = cycleCorners(cube, cycle);
			}
		}

		if (rotation) {
			cube = rotateCube(cube, rotation);
		}

		// The corners are flipped after the cube is rotated because the
		// orientations given refer to the final state of the cube.
		if (llcase.flipCorners) {
			const order = ['UFR', 'UFL', 'UBL', 'UBR'];
			for (let corner in llcase.flipCorners) {
				const orientation = llcase.flipCorners[corner];

				// Change the orientation of the corner where the specified
				// corner started.
				const index = cube.corners.indexOf(corner);
				cube.cornerOrientations[index] += orientation;
			}
		}

		for (var i = 0; i < 4; ++i) {
			drawCubelet(ctx, cube.corners[i], cube.cornerOrientations[i],
				cubeCorners[i], step);
			drawCubelet(ctx, cube.edges[i], cube.edgeOrientations[i],
				cubeEdges[i], step);
		}

		const cubeCenter = [
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + cubeletWidth,
			],
			[
				sideFaceWidth + 2 * cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
			[
				sideFaceWidth + cubeletWidth, sideFaceWidth + 2 * cubeletWidth,
			],
		];
		drawCubelet(ctx, 'U', 0, [cubeCenter]);

		let swaps = [];
		if (llcase.cycleEdges) {
			for (let cycle of llcase.cycleEdges)
				swaps.push(cycle);
		}
		if (llcase.cycleCorners) {
			for (let cycle of llcase.cycleCorners)
				swaps.push(cycle);
		}

		for (let cycle of swaps) {
			if (rotation) {
				cycle = cycleSwaps(cycle, rotation);
			}
			drawArrows(ctx, cycle);
		}

		return canvas;
	}

	function rotateCube(cube, rotation) {
		cube.edges = cycleArray(cube.edges, rotation);
		cube.edgeOrientations = cycleArray(cube.edgeOrientations, rotation);
		cube.corners = cycleArray(cube.corners, rotation);
		cube.cornerOrientations = cycleArray(cube.cornerOrientations, rotation);

		return cube;
	}

	function cycleEdges(cube, cycle) {
		const first = cube.edges[cycle[0]]
		for (var i = 1; i < cycle.length; ++i) {
			cube.edges[cycle[i - 1]] = cube.edges[cycle[i]];
		}
		cube.edges[cycle[cycle.length - 1]] = first;

		return cube;
	}

	function cycleCorners(cube, cycle) {
		const first = cube.corners[cycle[0]]
		for (var i = 1; i < cycle.length; ++i) {
			cube.corners[cycle[i - 1]] = cube.corners[cycle[i]];
		}
		cube.corners[cycle[cycle.length - 1]] = first;

		return cube;
	}

	function drawCubelet(ctx, faces, rot, squares, step) {
		rot = rot % 3;
		faces = cycleArray(faces, rot).join('');
		for (var j = 0; j < squares.length; ++j) {
			const points = squares[j];
			ctx.beginPath();
			ctx.moveTo(points[0][0], points[0][1]);
			for (var k = 1; k < points.length; ++k) {
				ctx.lineTo(points[k][0], points[k][1]);
			}
			ctx.lineTo(points[0][0], points[0][1]);
			ctx.fillStyle = stickerColor(faces[j], faces, step);
			ctx.fill();
			ctx.stroke();
		}
	}

	function stickerColor(face, piece, step) {
		switch(step) {
			case 'OLL':
			case 'OCLL':
				if (face != 'U') {
					face = 'G';
				}
				break;
			case 'EOLL':
				if (face !== 'U' || 3 === piece.length) {
					face = 'G';
				}
				break;
			case 'CPOLL':
				if (2 === piece.length) {
					face = 'G';
				}
				break;
		};

		// UFR and UBL are in anti-clockwise direction.
		if ('UFR' === piece) {
			if ('F' === face) {
				face = 'R';
			} else if ('R' === face) {
				face = 'F';
			}
		} else if ('UBL' === piece) {
			if ('B' === face) {
				face = 'L';
			} else if ('L' === face) {
				face = 'B';
			}
		}

		return cubeColors[face];
	}

	function drawArrow (ctx, p1, p2) {
		const angle = Math.atan2((p2[1] - p1[1]) , (p2[0] - p1[0]));
		const hyp = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));
		const size = 7;

		ctx.save();
		ctx.translate(p1[0], p1[1]);
		ctx.rotate(angle);

		ctx.beginPath();	
		ctx.moveTo(0, 0);
		ctx.lineTo(hyp - size, 0);
		ctx.stroke();

		ctx.beginPath();
		ctx.lineTo(hyp - size, size);
		ctx.lineTo(hyp, 0);
		ctx.lineTo(hyp - size, -size);
		ctx.fill();

		ctx.restore();
	}

	function drawArrows(ctx, cycle) {
		const coordinates = {
			UFR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UF: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UFL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
			],
			UL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
			UBL: [
				sideFaceWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UB: [
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UBR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth / 2,
			],
			UR: [
				sideFaceWidth + 2 * cubeletWidth + cubeletWidth / 2,
				sideFaceWidth + cubeletWidth + cubeletWidth / 2,
			],
		};
		
		ctx.strokeStyle = 'rgb(0, 0, 0)';
		ctx.fillStyle = 'rgb(0, 0, 0)';

		for (var i = 0; i < cycle.length; ++i) {
			const start = coordinates[cycle[i]];
			const end = coordinates[cycle[ i == cycle.length - 1 ? 0 : i + 1]];
			drawArrow(ctx, start, end);
		}
	}
});
		</script>
	</body>
</html>
